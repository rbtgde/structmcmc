# Part of the "structmcmc" package, http://github.com/rbtgde/structmcmc
# 
# This software is distributed under the GPL-3 license.  It is free,
# open source, and has the attribution requirements (GPL Section 7) in
#   http://github.com/rbtgde/structmcmc
# 
# Note that it is required that attributions are retained with each function.
#
# Copyright 2008 Robert J. B. Goudie, University of Warwick

#' method name
#'
#' method description
#'
#' @param sampler ...
#' @param samples ...
#' @param logScoreFUN this parameter was missing and R-check picked up on
#'   it.
#' @export
bnpostmcmc <- function(sampler, samples, logScoreFUN){
  stopifnot(class(sampler) ==   "function",
            "bn.list"      %in% class(samples))

  if (exists("lookup", envir = environment(sampler))){
    lookup <- get("lookup", envir = environment(sampler))
    count <- get("count", envir = environment(sampler))

    tabulated <- mget(ls(count), envir = count)
    bnlist <- mget(names(tabulated), envir = lookup)
    class(bnlist) <- c("bn.list", "parental.list")
    names(tabulated) <- as.character(bnlist)
    tabulated <- unlist(tabulated)
    tabulated <- sort.int(tabulated, method = "shell")
    tabulated <- as.table(tabulated)
  } else {
    tabulated <- pltabulate(samples, sort = T)
  }

  out <- new.env()
  out[["type"]] <- "mcmc"
  out[["logScoreFUN"]] <- evalq(expr  = logScoreFUN$offline,
                                envir = environment(sampler))
  out[["sampler"]] <- sampler
  out[["samples"]] <- samples
  out[["tabulated"]] <- tabulated
  out[["data"]] <- evalq(expr  = data,
                         envir = environment(sampler))

  class(out) <- "bnpostmcmc"
  out
}

#' method name
#'
#' method description
#'
#' @param ... Further arguments passed to method
#' @S3method bnpostmcmc list
#' @method bnpostmcmc list
#' @export
bnpostmcmc.list <- function(...){
  x <- list(...)
  class(x) <- "bnpostmcmc.list"
  x
}

#' Returns the number of samples draw in the supplied object of class
#' 'bnpostmcmc' x.
#'
#' @param x An object of class 'bnpostmcmc'
#' @param ... Further arguments passed to method
#' @return The number of samples in x
#' @S3method length bnpostmcmc
#' @method length bnpostmcmc
length.bnpostmcmc <- function(x, ...){
  stopifnot(class(x) == "bnpostmcmc")
  length(x$samples)
}

#' Returns the most commonly encountered graphs during the MCMC sampling
#' 'x'. The top 'head' graphs with respect to MCMC sampling are returned.
#' ie if the MCMC sampler has converged, the top graphs with respect to the
#' posterior distribution on graphs will be returned.
#'
#' @param x An object of class 'bnpostmcmc'
#' @param head The top head graphs will be returned. If the 'head'th
#'         most-commonly encountered graph ties in frequency with other
#'         graphs, all of the ties will be returned.
#' @param ... Further arguments (unused)
#' @return if head == 1:
#'     EITHER an object of class 'bn' containing the most commonly
#'     encountered graph,
#'     OR an object of class 'bn.list' containing a list of the equally most-
#'     commonly encountered graphs (if two or more were equally most-
#'     commonly) encountered
#'   if head > 1:
#'     an object of class 'bn.list' containing a list of the equally most-
#'     commonly encountered graphs
#' @S3method top bnpostmcmc
#' @method top bnpostmcmc
top.bnpostmcmc <- function(x, head = 10, ...){
  stopifnot(class(x) == "bnpostmcmc",
            is.wholenumber(head) || is.infinite(head),
            head > 0)
  tabulated <- x$tabulated
  rk <- rank(-tabulated, ties.method = "min") <= head
  top <- sort(tabulated[rk], dec = T)
  ids <- names(top)

  out <- as.parental(ids)
  if (length(ids) > 1){
    out <- lapply(out, function(bn){
      class(bn) <- c("bn", "parental")
      bn
    })
    class(out) <- c("bn.list", "parental.list")
  }
  else {
    class(out) <- c("bn", "parental")
  }
  out
}

#' Returns the most commonly encountered graph(s) during the MCMC sampling
#' 'x'. ie the maximum aposteriori graph(s).
#'
#' @param x An object of class 'bnpostmcmc'
#' @param ... Further arguments (unused)
#' @return
#'   EITHER an object of class 'bn' containing the most commonly
#'   encountered graph,
#'   OR an object of class 'bn.list' containing a list of the equally most-
#'   commonly encountered graphs (if two or more were equally most-
#'   commonly) encountered
#' @S3method map bnpostmcmc
#' @method map bnpostmcmc
map.bnpostmcmc <- function(x, ...){
  stopifnot(class(x) == "bnpostmcmc")
  top(x, head = 1)
}

#' Returns the log scores of the best graphs encountered by the sampler.
#'
#' @param x An object of class 'bnpostmcmc'
#' @param sampler A function generated by BNSampler() or similar
#' @param data A data.frame of the form required by logScoreMultDir()
#' @param sort.by A character of length 1. Either "posterior" or
#'              "logScoreMultDir".
#'              Determines the sorting of the result, and if head is finite
#'              and smaller than the number of graphs encountered in the
#'              MCMC, it also determines the graphs for which the scores are
#'              returned.
#'              if sort.by == "posterior":
#'                the scores of the most frequently encountered graphs
#'                are returned, sorted by the frequency that they are
#'                encountered. ie if the MCMC has converged, this returns
#'                best graphs with respect to the posterior distribution on
#'                graphs, sorted with respect to the posterior distribution
#'                on graphs.
#'              if sort.by == "logScoreMultDir":
#'                the scores of the graphs encountered during MCMC that
#'                score the most highly according to logScoreMultDir() are
#'                returned. This will be slower, because the scores of ALL
#'                the graphs encountered must be computed first (only local,
#'                incremental scores are stored by the MCMC)
#' @param head A numeric of length 1. The 1st to headth most-highly scoring
#'              (with respect to the sort.by metric) will be returned.
#'              If the 'head'th most-commonly encountered graph ties in
#'              score with other graphs, all of the ties will be returned.
#'              Thus the result may NOT be of length head.
#' @param use.names A logical of length 1. If TRUE, the result is a named vector,
#'              with names given by as.character(bn)
#' @param ... Further arguments passed to logScoreMultDir()
#'
#' @return A vector of length at least head (if head is finite), giving the
#'   logScoreMultDir() of the graphs, or all the graphs encountered during
#'   MCMC if head == Inf.
#' @S3method logScoreMultDir bnpostmcmc
#' @method logScoreMultDir bnpostmcmc
logScoreMultDir.bnpostmcmc <- function(x, sampler, data,
                                       sort.by   = "posterior",
                                       head      = Inf,
                                       use.names = F, ...){
  stopifnot(class(x)          ==   "bnpostmcmc",
            class(sampler)    ==   "function",
            class(data)       ==   "data.frame",
            is.wholenumber(head) || is.infinite(head),
            head              >    0,
            sort.by           %in% c("posterior", "logScoreMultDir"),
            class(use.names)  ==   "logical",
            length(use.names) ==   1)
  # extract the cache from the sampler to speed up computation
  cache <- get("cache", envir = environment(sampler))
  # we must score all the graphs if we sort by logScoreMultDir
  if (sort.by == "logScoreMultDir"){
    bnptop <- top(x, head = Inf)
  }
  else {
    bnptop <- top(x, head = head)
  }
  res <- logScoreMultDir(bnptop, data, cache = cache, ...)
  if ("bn" %in% class(bnptop)){
    # TODO: this seems like a bit of a fiddle.
    res <- res[[1]]
  }
  if (isTRUE(use.names)){
    names(res) <- as.character(bnptop)
  }
  if (sort.by == "logScoreMultDir"){
    rk <- rank(-res, ties.method = "min") <= head
    res <- sort(res[rk], dec = T)
  }
  res
}

#' method name
#'
#' method description
#'
#' @param x ...
#' @param logNetworkPriors ...
#' @param start ...
#' @param end ...
#' @param nbin ...
#' @param log ...
#' @param pretty ...
#' @param levels ...
#' @param ... Further arguments (unused)
#' @S3method gp bnpostmcmc
#' @method gp bnpostmcmc
gp.bnpostmcmc <- function(x, logNetworkPriors, start, end, nbin = 1,
                          log = F, pretty = F, levels = NULL, ...){
  warning("does not handle priors, nor logging")

  makeNames <- function(tabulatedProportions){
    # a probably suboptimal shuffle so as to keep names
    if (pretty){
      bnl <- as.parental(names(tabulatedProportions))
      ids <- as.character(bnl, pretty = T)
    }
    else {
      ids <- names(tabulatedProportions)
    }
    tabulatedProportions <- as.vector(tabulatedProportions)
    names(tabulatedProportions) <- ids
    tabulatedProportions
  }

  if (nbin == 1){
    nSamples <- length(x$samples)
    out <- x$tabulated/nSamples

    out <- makeNames(out)

    class(out) <- "gp"
    out
  }
  else {
    # if the nbin > 1, we have to retabulate
    lengthOfRuns <- length(x$samples)
    sizeOfBins <- lengthOfRuns/nbin
    if (round(sizeOfBins) != sizeOfBins) stop("nbin not an integer malarkey")
    samples <- x$samples

    #bins <- split(samples, rep(seq_len(nbin), each = sizeOfBins))
    if (is.null(levels)){
      levels <- names(x$tabulated)
    }

    # loop over the bins
    outs <- lapply(seq_len(nbin), function(bin){
      samples <- samples[
        seq.int(
          from = sizeOfBins * (bin - 1) + 1,
          to = sizeOfBins * bin
        )
      ]
      class(samples) <- c("parental.list")

      # need to keep this sorted according to the levels
      out <- pltabulate(samples, levels = levels,
                        pretty = pretty, sort = F)
      out <- out/length(samples)

      #out <- makeNames(out, pretty)
      class(out) <- "gp"
      out
    })
    class(outs) <- "gp.list"
    outs
  }
}

#' method name
#'
#' method description
#'
#' @param x ...
#' @param ... Further arguments passed to method
#' @S3method gp bnpostmcmc.list
#' @method gp bnpostmcmc.list
gp.bnpostmcmc.list <- function(x, ...){
  stopifnot(class(x) == "bnpostmcmc.list")
  lapply(x, gp, ...)
}

#' Computes the edge probabilities implied by the MCMC samples
#' contained in the 'bnpostmcmc' object x.
#'
#' @param x An object of class 'bnpostmcmc'
#' @param nbin A numberic vector of length 1 specifying the number of bins
#'           into which to divide the MCMC samples. The edge probabilities
#'           are computed separately for each bin.
#' @param start ...
#' @param end ...
#' @param method Either "flatten" (the default) or "tabulate".
#' @param verbose ...
#' @param ... Further arguments passed to ep.parental.list() for method =
#'           "flatten", or ep.table() for method = "tabulate"
#' @return if nbin == 1:
#'     A matrix of class 'ep' with entry (i,j) containing the probability of
#'     an edge from node i --> j
#'   if nbin > 1:
#'     A list of class ep.list, containing matrices as described above for
#'     each of the nbin bins into which the parental.list was split
#' @S3method ep bnpostmcmc
#' @method ep bnpostmcmc
ep.bnpostmcmc <- function(x, nbin = 1, start, end, method = "flatten",
                          verbose = F, ...){
  stopifnot(class(x) == "bnpostmcmc",
            isTRUE(is.wholenumber(nbin)),
            method %in% c("flatten", "tabulate"))

  if (method == "flatten"){
    if (verbose){
      cat("doing the flaten method\n")
    }
    ep(x$samples, nbin, ...)
  }
  else if (method == "tabulate"){
    if (nbin != 1){
      stop("method = tabulate not implemented for nbin != 1")
    }
    if (verbose) cat("Compiling ep by tabulating\n")

    sampler <- x$sampler
    if (exists("lookup", envir = environment(sampler))){
      if (verbose) cat("Looking up tabulation from environment\n")
      lookup <- get("lookup", envir = environment(sampler))
      count <- get("count", envir = environment(sampler))

      tabulated <- unlist(mget(ls(count), envir = count))
      bnlist <- mget(names(tabulated), envir = lookup)
      class(bnlist) <- c("bn.list", "parental.list")

      pc <- list(parental.list = bnlist,
                 contingency   = tabulated)

      class(pc) <- "parental.contingency"
      ep(pc, verbose = verbose, ...)
    } else {
      ep(x$tabulated, verbose = verbose, ...)
    }
  }
}

#' method name
#'
#' method description
#'
#' @param x ...
#' @param start ...
#' @param end ...
#' @param ... further arguments
#' @S3method ep bnpostmcmc.list
#' @method ep bnpostmcmc.list
ep.bnpostmcmc.list <- function(x, start, end, ...){
  stopifnot(class(x) == "bnpostmcmc.list")
  if (!missing(start) || !missing(end)){
    warning("Start/end not implemented")
  }
  # FIXME: using ep.bnpostmcmc is a temporary fix
  # otherwise method dispatches to ep.parental.list
  res <- lapply(x, function(y){
    ep(y, ...)
  })
  class(res) <- "ep.list"
  res
}